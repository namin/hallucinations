;; shift-register 
(defun make-2D-shift-register (rows times &optional (fill-fn (lambda () nil)))
  (let ((sr (make-array (list rows times))))
    (dotimes (i rows)
      (dotimes (j times)
	(setf (aref sr i j) (funcall fill-fn))))
    sr))
  
(defun shift-left (register num &optional (fill-fn (lambda () nil)))
  (destructuring-bind (x y) (array-dimensions register)
    (dotimes (i x)
      (dotimes (j (- y num))
	(setf (aref register i j) (aref register i (+ j num))))
      (dotimes (j num)
	(setf (aref register i (+ j (- y num))) (funcall fill-fn))))))
(defun shift-right (register num &optional (fill-fn (lambda () nil)))
  (destructuring-bind (x y) (array-dimensions register)
    (dotimes (i x)
      (dotimes (j (- y num))
	(setf (aref register i (- y j 1)) (aref register i (- y j num 1))))
      (dotimes (j num)
	(setf (aref register i j) (funcall fill-fn))))))

(defun shift-up (register num &optional (fill-fn (lambda () nil)))
  (destructuring-bind (x y) (array-dimensions register)
    (dotimes (i y)
      (dotimes (j (- x num))
	(setf (aref register j i) (aref register (+ j num) i)))
      (dotimes (j num)
	(setf (aref register (+ j (- x num)) i) (funcall fill-fn))))))
(defun shift-down (register num &optional (fill-fn (lambda () nil)))
  (destructuring-bind (x y) (array-dimensions register)
    (dotimes (i y)
      (dotimes (j (- x num))
	(setf (aref register (- x j 1) i) (aref register (- x j num 1) i)))
      (dotimes (j num)
	(setf (aref register j i) (funcall fill-fn))))))

(defun rows (register) (array-dimension register 0))
(defun cols (register) (array-dimension register 1))

(defregression test-shift-register
  (let ((reg (make-2D-shift-register 3 4))
	(data '((A B C D) (E F G H) (I J K L))))
    (setf reg (make-array '(3 4) :initial-contents data)) (shift-left reg 2)
    (assert (eqv reg #2A((C D nil nil) (G H nil nil) (K L nil nil))))
    (setf reg (make-array '(3 4) :initial-contents data)) (shift-right reg 3)
    (assert (eqv reg #2A((nil nil nil A) (nil nil nil E) (nil nil nil I))))
    (setf reg (make-array '(3 4) :initial-contents data)) (shift-up reg 2)
    (assert (eqv reg #2A((I J K L) (nil nil nil nil) (nil nil nil nil))))
    (setf reg (make-array '(3 4) :initial-contents data)) 
    (shift-down reg 1 (lambda () (list 'x 'y)))
    (assert (eqv reg #2A(((X Y) (X Y) (X Y) (X Y)) (A B C D) (E F G H))))
    'ok))
